---
title: "Простейшая сгенерированная форма"
description: ""
weight: 1
---

В данном примере мы рассмотрим самые основы работы с генератором форм. Перед нами стоит следующая задача: сгенерировать форму регистрации пользователя, содержащую три поля и две кнопки. Задача является преднамеренно упрощенной, чтобы не приходилось отвлекаться на детали бизнес-логики. В последующих статьях мы рассмотрим, как сгененрировать более сложные формы.

Поля будут следующие: "E-mail", "Пароль", "Подтверждение пароля".<br>
Кнопки: "Отправить" и "Очистить".

Начнем мы с создания простейшей структуры реакт-приложения:

```js
// App.jsx

import React from 'react';
import ReactDOM from 'react-dom'

class App extends React.Component {
  render() {
    return (
        <div>placeholder</div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

Пока-что, ничего интересного в этом коде нет - всего лишь создание пустого реакт-компонента, который выводит единственный `div` с текстом "placeholder".
Чтобы добавить в это приложение сгенерированную форму, для начала нужно сделать импорт необходимых компонентов:


```js
// App.jsx

import React from 'react';
import ReactDOM from 'react-dom'

import { GeneratedForm, Fields } from '@react-ui-generator/core'

...
```

Здесь мы импортировали два важнейших компонента реакта. Из названия, вероятно, уже стало понятно чем занимается компонент `GeneratedForm` - очевидно, генерацией формы. А вот каково предназначение компонента `Fields` станет понятно чуть позже.

Добавим инстанс формы в приложение:

```js
// App.jsx

import React from 'react';
import ReactDOM from 'react-dom'
import { GeneratedForm, Fields } from '@react-ui-generator/core'

class App extends React.Component {
  render() {
    return (
        <GeneratedForm
            meta={/* ??? */}
            data={/* ??? */}
            renderers={/* ??? */}
            onChange={/* ??? */}
        />
    );
  }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

Как видим, форма содержит четыре свойства (на самом деле их [больше](/#todo-link-to-api)), которые пока-что отмечены вопросительными знаками.
Собственно, заполнением этих свойств правильными значениями мы и займемся в оставшейся части статьи.

## `meta`

Свойство `meta` содержит мета-описание нашей формы. Мета-описание являет собою js-объект, описывающий структуру желаемой формы, включая набор полей, их названия, типы и т.д.

Вот как будет выглядеть мета-описание для нашей формы:

```js
// sign-up-meta.json

{
  "fields": [
    {
      "id": "email",
      "renderer": "text",
    },

    {
      "id": "password",
      "renderer": "text",
    },

    {
      "id": "confirmation",
      "renderer": "text",
    },

    {
      "id": "btnSend",
      "renderer": "button",
    },

    {
      "id": "btnClear",
      "renderer": "button",
    }
  ]
}

```

Как видите, в самом простом своем представлении мета-данные выглядят достаточно... просто. На самом деле здесь не хватает многих важных настроек, которые в итоге значительно увеличат размер нашего мета-описания, но - есть надежда - не слишком усложнят его для понимания.

Итак, в этом мета-описании мы задаем единственное верхнеуровневое свойство `fields`, содержаее массив с объектами-описаниями полей.
Каждое поле описывается двумя свойствами: `id` и `renderer`, последнее из которых описывает тип UI-компонента, которым данное поле будет представлено на форме.

## `data`

Свойство `data` компонента `GeneratedForm` содержит текущее значение полей формы. Как сказано в описании _React UI Generator_, генерируемые им формы являются **чистыми** компонентами, а это значит, что все данные, которые отображает форма, должны приходить к ней в виде `props`.

Структура объекта, использующегося в качестве значения `data`, такова:

```js
// App.jsx

...

const initialData = {
    email: { value: '', isDirty: false },
    password: { value: '', isDirty: false },
    confirmation: { value: '', isDirty: false },
}

...

class App extends React.Component {
    ...
}
```

Можно сказать, что `data` содержит актуальное *состояние* каждого поля: его значение и признак того, что в поле уже происходил пользовательский ввод.
Однако, забегая наперед, скажу что данное свойство НЕ содержит ошибки валидации поля. Для простоты манипулирования ими, ошибки вынесены в отдельное свойство `errors`, к которому мы ещё вернемся.

Пока же перейдем к следующему свойству нашего инстанса `GeneratedForm`.

## `renderers`

Это, пожалуй, самое интересное свойство, если можно так сказать. Именно оно определяет, какие в принципе типы полей допустимы для данной формы. По-сути, `renderers` содержит коллекцию функций-отрисовщиков, каждая из которых умеет отрисовывать поле определенного типа: `text`, `button` и пр.

Для того, чтобы заполнить это поле из нашего пример, нам потребуется добавить ещё один `import`:


```js
// App.jsx

import React from 'react';
...
import { Renderers: BootstrapRenderers } from '@react-ui-generator/bootstrap'

...

class App extends React.Component {
  render() {
    return (
        <GeneratedForm
            ...
            renderers={BootstrapRenderers}
            ...
        />
    );
  }
}

...
```

Для тех кому любопытно, сразу скажу, что `BootsrapRenderers` имеет очень простую структуру:

```js
{
    'text': function () { ... },
    'button': function () { ... },
    ...
}
```

Мы поговорим об устройстве renderers очень детально, когда дойдем до создания собственных типов полей. А сейчас лучше поговорим об `onChange` и затем перейдем к тому, чтобы собрать все вместе.

## `onChange`